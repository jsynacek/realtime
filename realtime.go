package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	DROPIN   = "99-realtime.conf"
	SLICE    = "realtime.slice"
	TEMPLATE = `# Generated realtime dropin
[Service]
Slice=realtime.slice
CPUAccounting=yes
ExecStartPre=/bin/bash -c 'echo %d > %s'
`
	START = `[Service]
Slice=realtime.slice
ExecStart=/bin/bash -c "echo >/dev/null"
CPUAccounting=yes
RemainAfterExit=yes
`
)

var (
	optVerbose = flag.Bool("v", false, "verbose mode")
	optClean   = flag.Bool("c", false, "only clean generated drop-ins")
)

type Config map[string]int

func logInfo(format string, v ...interface{}) {
	if *optVerbose {
		log.Printf(format, v...)
	}
}

func reloadSystemd() {
	logInfo("reloading systemd")
	err := exec.Command("systemctl", "daemon-reload").Run()
	if err != nil {
		log.Fatalf("failed to reload systemd daemon: %v", err)
	}
}

// Create starting unit if it doesn't exist.
func createStartUnit() bool {
	file := "/etc/systemd/system/realtime-start.service"
	_, err := os.Stat(file)
	if err != nil { // Assume that the file doesn't exist.
		logInfo("creating realtime-start.service")
		err = ioutil.WriteFile(file, []byte(START), 0644)
		if err != nil {
			log.Fatalf("failed to write %s: %v", file, err)
		}
		return true
	}
	return false
}

// Read the default runtime_us or period_us from the /proc tree.
func readDefault(name string) (value int) {
	p := "/proc/sys/kernel/sched_rt_" + name + "_us"
	data, err := ioutil.ReadFile(p)
	if err != nil {
		log.Fatalf("cannot read %s", p)
	}
	data = bytes.TrimSpace(data)
	value, err = strconv.Atoi(string(data))
	if err != nil {
		log.Fatalf("failed to convert %s_us", name)
	}
	return
}

// Read configuration from /etc/systemd/realtime.conf.
// The format is "<service name> : <runtime budget>" per line. The values can be delimited
// by any amount of whitespace.
func readConfig(maxRuntime int) (Config, error) {
	f, err := os.Open("/etc/systemd/realtime.conf")
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var cfg Config = make(map[string]int)
	b := bufio.NewReader(f)
	l, r := 1, 0
	for {
		line, err := b.ReadBytes('\n')
		if err == io.EOF {
			break
		}
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		parts := bytes.Split(line, []byte(":"))
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid configuration: %q on line %d", string(line), l)
		}
		parts[0] = bytes.TrimSpace(parts[0])
		parts[1] = bytes.TrimSpace(parts[1])
		val, err := strconv.Atoi(string(parts[1]))
		if err != nil {
			return nil, fmt.Errorf("invalid configuration: %q on line %d: %v", string(line), l, err)
		}
		cfg[string(parts[0])] = val
		r += val
		l++
	}
	if r > maxRuntime {
		return nil, fmt.Errorf("invalid configuration: runtime budget too high: %d > %d", r, maxRuntime)
	}
	return cfg, nil

}

// Delete all realtime dropins possibly generated by this program.
func deleteDropins() error {
	return filepath.Walk("/etc/systemd/system/", func(file string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if path.Base(file) == DROPIN {
			logInfo("deleting %s", file)
			err = os.Remove(file)
			if err != nil {
				return err
			}
		}
		return nil
	})
}

// Find unit in systemd directories.
func findUnit(name string) (unit string) {
	for _, dir := range []string{"/etc/systemd/system", "/usr/lib/systemd/system"} {
		unit = path.Join(dir, name)
		_, err := os.Stat(unit)
		if err == nil {
			return
		}
	}
	return ""
}

// Apply the configuration.
func (c *Config) apply(rootRuntime int) {
	// Default runtime_us has to be copied down the hierarchy to the realtime slice.
	cgroup := path.Join("/sys/fs/cgroup/cpu", SLICE, "cpu.rt_runtime_us")
	err := ioutil.WriteFile(cgroup, []byte(strconv.Itoa(rootRuntime)), 0644)
	if err != nil {
		log.Fatalf("failed to write runtime_us: %v", err)
	}

	for service, runtime := range *c {
		name := service
		if !strings.HasSuffix(name, ".service") {
			name += ".service"
		}

		unit := findUnit(name)
		if len(unit) == 0 {
			logInfo("%s does not exist, skipping", name)
			continue
		}

		dropinDir := path.Join("/etc/systemd/system/", name+".d")
		err = os.Mkdir(dropinDir, 0644)
		if err != nil && !os.IsExist(err) {
			logInfo("failed to create directory: %v", err)
			continue
		}

		dropin := path.Join(dropinDir, "99-realtime.conf")
		cgroup = path.Join("/sys/fs/cgroup/cpu", SLICE, name, "cpu.rt_runtime_us")

		logInfo("creating %s for %s", dropin, name)
		err = ioutil.WriteFile(dropin, []byte(fmt.Sprintf(TEMPLATE, runtime, cgroup)), 0644)
		if err != nil {
			logInfo("failed to write to %s: %v", dropin, err)
		}
	}
}

func main() {
	flag.Parse()

	if *optClean {
		deleteDropins()
		return
	}

	ok := createStartUnit()
	if ok {
		reloadSystemd()
	}

	err := exec.Command("systemctl", "start", "realtime-start").Run()
	if err != nil {
		log.Fatalf("failed to start realtime-start.service: %v", err)
	}

	rootRuntime := readDefault("runtime")
	config, err := readConfig(rootRuntime)
	if err != nil {
		log.Fatal(err)
	}

	deleteDropins()
	config.apply(rootRuntime)
	reloadSystemd()
}

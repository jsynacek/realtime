package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strconv"
)

const (
	DROPIN   = "99-realtime.conf"
	SLICE    = "realtime.slice"
	TEMPLATE = `# Generated realtime dropin
[Service]
Slice=realtime.slice
CPUAccounting=yes
ExecStartPre=/bin/bash -c 'echo %d > %s'
`
	START = `[Service]
Slice=realtime.slice
ExecStart=/bin/bash -c "echo >/dev/null"
CPUAccounting=yes
RemainAfterExit=yes
`
)

var (
	optVerbose = flag.Bool("v", false, "verbose mode")
	optClean   = flag.Bool("c", false, "only clean generated drop-ins")
)

type Config struct {
	data map[string]int
	sum  int
	max  int
}

func newConfig(maxRuntime int) *Config {
	return &Config{make(map[string]int), 0, maxRuntime}
}

func logInfo(format string, v ...interface{}) {
	if *optVerbose {
		log.Printf(format, v...)
	}
}

func reloadSystemd() {
	logInfo("reloading systemd")
	err := exec.Command("systemctl", "daemon-reload").Run()
	if err != nil {
		log.Fatalf("failed to reload systemd daemon: %v", err)
	}
}

// Create starting unit if it doesn't exist.
func createStartUnit() bool {
	file := "/etc/systemd/system/realtime-start.service"
	_, err := os.Stat(file)
	if err != nil { // Assume that the file doesn't exist.
		logInfo("creating realtime-start.service")
		err = ioutil.WriteFile(file, []byte(START), 0644)
		if err != nil {
			log.Fatalf("failed to write %s: %v", file, err)
		}
		return true
	}
	return false
}

// Read the default runtime_us or period_us from the /proc tree.
func readDefault(name string) (value int) {
	p := "/proc/sys/kernel/sched_rt_" + name + "_us"
	data, err := ioutil.ReadFile(p)
	if err != nil {
		log.Fatalf("cannot read %s", p)
	}
	data = bytes.TrimSpace(data)
	value, err = strconv.Atoi(string(data))
	if err != nil {
		log.Fatalf("failed to convert %s_us", name)
	}
	return
}

// Find unit in systemd directories.
func findUnit(name string) (unit string) {
	for _, dir := range []string{"/etc/systemd/system", "/usr/lib/systemd/system"} {
		unit = path.Join(dir, name)
		_, err := os.Stat(unit)
		if err == nil {
			return
		}
	}
	return ""
}

func unitName(unit string) (name string) {
	name = unit
	if path.Ext(name) != ".service" {
		name += ".service"
	}
	return
}

// Read configuration from a file.
// The format is "<service name> : <runtime budget>" per line. The values can be delimited
// by any amount of whitespace.
func (c *Config) readConfig(file string) error {
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()

	b := bufio.NewReader(f)
	l := 0
	for {
		line, err := b.ReadBytes('\n')
		if err == io.EOF {
			break
		}
		l++
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		parts := bytes.Split(line, []byte(":"))
		if len(parts) != 2 {
			return fmt.Errorf("invalid configuration: %s:%d %q", file, l, string(line))
		}
		parts[0] = bytes.TrimSpace(parts[0])
		parts[1] = bytes.TrimSpace(parts[1])
		val, err := strconv.Atoi(string(parts[1]))
		if err != nil {
			return fmt.Errorf("invalid configuration: %s:%d %q", file, l, string(line))
		}

		key := string(parts[0])
		name := unitName(key)
		unit := findUnit(name)
		if len(unit) == 0 {
			logInfo("%s does not exist, skipping", name)
			continue
		}

		v, ok := c.data[key]
		if ok {
			c.sum -= v
		}
		c.data[key] = val
		c.sum += val
	}
	return nil
}

func readConfig(maxRuntime int) (*Config, error) {
	cfg := newConfig(maxRuntime)
	err := cfg.readConfig("/etc/systemd/realtime.conf")
	if err != nil {
		return nil, err
	}
	// No problem if /etc/systemd/realtime.conf.d doesn't exist.
	if _, err = os.Stat("/etc/systemd/realtime.conf.d/"); os.IsNotExist(err) {
		return cfg, nil
	}
	err = filepath.Walk("/etc/systemd/realtime.conf.d/", func (file string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if path.Ext(file) == ".conf" {
			err = cfg.readConfig(file)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if cfg.sum > cfg.max {
		return nil, fmt.Errorf("invalid configuration: runtime budget too high: %d > %d", cfg.sum, cfg.max)
	}
	return cfg, err
}

// Delete all realtime dropins possibly generated by this program.
func deleteDropins() error {
	return filepath.Walk("/etc/systemd/system/", func(file string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if path.Base(file) == DROPIN {
			logInfo("deleting %s", file)
			err = os.Remove(file)
			if err != nil {
				return err
			}
		}
		return nil
	})
}

// Apply the configuration.
func (c *Config) apply(rootRuntime int) {
	// Default runtime_us has to be copied down the hierarchy to the realtime slice.
	cgroup := path.Join("/sys/fs/cgroup/cpu", SLICE, "cpu.rt_runtime_us")
	err := ioutil.WriteFile(cgroup, []byte(strconv.Itoa(rootRuntime)), 0644)
	if err != nil {
		log.Fatalf("failed to write runtime_us: %v", err)
	}

	for service, runtime := range c.data {
		dropinDir := path.Join("/etc/systemd/system/", service+".d")
		err = os.Mkdir(dropinDir, 0644)
		if err != nil && !os.IsExist(err) {
			logInfo("failed to create directory: %v", err)
			continue
		}

		dropin := path.Join(dropinDir, "99-realtime.conf")
		cgroup = path.Join("/sys/fs/cgroup/cpu", SLICE, service, "cpu.rt_runtime_us")

		logInfo("creating %s for %s", dropin, service)
		err = ioutil.WriteFile(dropin, []byte(fmt.Sprintf(TEMPLATE, runtime, cgroup)), 0644)
		if err != nil {
			logInfo("failed to write to %s: %v", dropin, err)
		}
	}
}

func main() {
	flag.Parse()

	if *optClean {
		deleteDropins()
		return
	}

	ok := createStartUnit()
	if ok {
		reloadSystemd()
	}

	err := exec.Command("systemctl", "start", "realtime-start").Run()
	if err != nil {
		log.Fatalf("failed to start realtime-start.service: %v", err)
	}

	rootRuntime := readDefault("runtime")
	config, err := readConfig(rootRuntime)
	if err != nil {
		log.Fatal(err)
	}

	deleteDropins()
	config.apply(rootRuntime)
	reloadSystemd()
}
